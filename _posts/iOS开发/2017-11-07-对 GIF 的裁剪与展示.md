---
category: iOS开发
description: "GIF 裁剪过程可以大致分为三步"
---

GIF 裁剪过程可以大致分为三步

* 获取 GIF 的帧集合，并对每一帧图片进行裁剪后生成裁剪后的 UIImage 对象
* 裁剪后的 GIF 的 NSData 数据

这里主要用到了 Image I/O 的相关接口，Image I/O framework 提供一种不透明的数据类型（opaque data types），从 CGImageSourceRef 获取图片数据，将图片数据写入到 CGImageDestinationRef。它提供一个范围很广的图片格式，包含 web 格式，动态图，原始相机数据等。

## 获取帧集合并裁剪

首先是获取 GIF 的帧集合。

* 通过 GIF 的 NSData 创建一个 CGImageSourceRef 对象

```objective_c
CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)assetData, NULL);
```

这里 CGImageSourceRef 就是一个代表图片的不透明的数据类型，它抽象了读取图像数据的通道，但本身不会读取图像的任何数据。

* 获取 GIF 帧的个数

```objective_c
size_t count = CGImageSourceGetCount(source);
```

对于 GIF 等 AnimateImage 对象可以包含多个 Image，这里 CGImageSourceGetCount 就可以获取到对应的源图片数据的帧数。

* 获取帧集合并裁剪

```objective_c
            NSMutableArray *images = [NSMutableArray array];
            NSTimeInterval duration = (1.0f / 100.0f) * count;
            for (size_t i = 0; i < count; i++) {
                CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL);
                CGImageRef newImageRef = CGImageCreateWithImageInRect(image, cropRect);
                UIImage *newImage = [UIImage imageWithCGImage:newImageRef];
                [images addObject:newImage];
                CGImageRelease(image);
            }
            animatedImage = [UIImage animatedImageWithImages:images duration:duration];
```

GIF 的一个重要属性是它的 duration 值，这里简单取为帧数的 10%，相当于每一帧的 duration 是 0.1s。SDWebImage 库的 SDWebImageGIFCoder.m 文件中提供了一种更准确的获取方法

```objective_c
- (float)sd_frameDurationAtIndex:(NSUInteger)index source:(CGImageSourceRef)source {
    float frameDuration = 0.1f;
    CFDictionaryRef cfFrameProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil);
    NSDictionary *frameProperties = (__bridge NSDictionary *)cfFrameProperties;
    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary];
    
    NSNumber *delayTimeUnclampedProp = gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime];
    if (delayTimeUnclampedProp) {
        frameDuration = [delayTimeUnclampedProp floatValue];
    } else {
        NSNumber *delayTimeProp = gifProperties[(NSString *)kCGImagePropertyGIFDelayTime];
        if (delayTimeProp) {
            frameDuration = [delayTimeProp floatValue];
        }
    }
    
    // Many annoying ads specify a 0 duration to make an image flash as quickly as possible.
    // We follow Firefox's behavior and use a duration of 100 ms for any frames that specify
    // a duration of <= 10 ms. See <rdar://problem/7689300> and <http://webkit.org/b/36082>
    // for more information.
    
    if (frameDuration < 0.011f) {
        frameDuration = 0.100f;
    }
    
    CFRelease(cfFrameProperties);
    return frameDuration;
}
```

通过 CGImageSourceCreateImageAtIndex 方法我们可以从一个 CGImageSourceRef 数据源中读到一个帧位的未解码图片数据，然后通过 CGImageCreateWithImageInRect 对这一帧数据进行裁剪后，解码生成一个 UIImage 对象，将其放入一个数组中。最后通过 [UIImage animatedImageWithImages: duration:] 方法来生成一个被裁剪后的 GIF 的 UIImage 对象。这时候 __可以把这个 UIImage 对象赋给 UIImageView 对象来展示一个 GIF 图片__。

最后要注意手动释放 CGImageSourceRef 对象

```objecvivec
CFRelease(source);
```

## 获取裁剪后的 NSData

如果要传输裁剪后的 GIF 图片给服务器，还需要将上一步得到的 UIImage 转化为 NSData 对象。

```objective_c
            size_t frameCount = animatedImage.images.count;
            NSTimeInterval frameDuration = animatedImage.duration / frameCount;
            NSDictionary *frameProperties = @{
                                              (__bridge NSString *)kCGImagePropertyGIFDictionary: @{
                                                      (__bridge NSString *)kCGImagePropertyGIFDelayTime: @(frameDuration)
                                                      }
                                              };
            NSMutableData *mutableData = [NSMutableData data];
            NSDictionary *imageProperties = @{ (__bridge NSString *)kCGImagePropertyGIFDictionary: @{
                                                       (__bridge NSString *)kCGImagePropertyGIFLoopCount: @0
                                                       }
                                               };
            CGImageDestinationRef destination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)mutableData, kUTTypeGIF, frameCount, NULL);
            CGImageDestinationSetProperties(destination, (__bridge CFDictionaryRef)imageProperties);
            for (size_t index = 0; index < frameCount;index++) {
                CGImageDestinationAddImage(destination, [[animatedImage.images objectAtIndex:index] CGImage], (__bridge CFDictionaryRef)frameProperties);
            }
            BOOL success = CGImageDestinationFinalize(destination);
            CFRelease(destination);
```

这里通过上一步得到的 UIImage 对象，首先获得 GIF 图的帧数，然后获得每一帧的 duration。同时创建一个 NSMutableData 的对象用于存储 GIF 图片的数据，然后创建一个 CGImageDestinationRef 来指定存入数据区（mutableData）、存入数据类型（kUTTypeGIF）和帧数（frameCount）。最后遍历 animatedImage 的每一个 UIImage 对象，依据每一帧的 duration 值存入 CGImageDestinationRef 对象中。执行完遍历操作后，mutableData 中就是我们需要的裁剪后的 GIF 图片的 NSData 数据。